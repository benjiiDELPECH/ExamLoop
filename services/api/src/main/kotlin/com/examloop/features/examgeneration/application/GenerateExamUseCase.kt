package com.examloop.features.examgeneration.application

import com.examloop.features.examgeneration.domain.*
import com.examloop.features.learning.application.*
import com.examloop.features.learning.domain.*
import org.slf4j.LoggerFactory
import java.time.Instant

/**
 * GenerateExamUseCase ‚Äî G√©n√®re un examen avec questions IA
 * 
 * Flow:
 * 1. V√©rifier que l'utilisateur est premium
 * 2. Cr√©er le goal (exam)
 * 3. G√©n√©rer les questions via IA
 * 4. Sauvegarder les questions
 * 5. Retourner l'examen cr√©√©
 */
class GenerateExamUseCase(
    private val profilePort: ProfilePort,
    private val goalPort: GoalPort,
    private val questionPort: QuestionPort,
    private val questionGeneratorPort: QuestionGeneratorPort,
    private val clockPort: ClockPort
) {
    private val log = LoggerFactory.getLogger(GenerateExamUseCase::class.java)

    data class Command(
        val userId: UserId,
        val topic: String,
        val description: String? = null,
        val questionCount: Int = 10,
        val difficultyMix: DifficultyMix = DifficultyMix.BALANCED,
        val questionTypes: List<QuestionType> = listOf(QuestionType.SINGLE_CHOICE),
        val language: String = "fr"
    )

    suspend fun execute(command: Command): GenerateExamResult {
        log.info("üß† GenerateExam - userId: {}, topic: {}, count: {}",
            command.userId.value, command.topic, command.questionCount)

        val now = clockPort.now()

        // 1. V√©rifier premium
        val profile = profilePort.findById(command.userId)
        if (profile == null || !profile.premium) {
            log.warn("‚ö†Ô∏è User not premium: {}", command.userId.value)
            return GenerateExamResult.NotPremium(
                message = "La g√©n√©ration IA n√©cessite un abonnement Premium"
            )
        }

        // 2. Cr√©er le goal (exam)
        val goal = Goal(
            id = GoalId(0L), // Generated by DB
            userId = command.userId,
            title = command.topic,
            description = command.description ?: "Examen g√©n√©r√© par IA sur ${command.topic}",
            isPublic = false,
            createdAt = now
        )
        val savedGoal = goalPort.save(goal)
        log.info("‚úÖ Goal created: {}", savedGoal.id.value)

        // 3. G√©n√©rer les questions via IA
        val config = ExamGenerationConfig(
            topic = command.topic,
            description = command.description,
            questionCount = command.questionCount,
            targetDifficulty = command.difficultyMix,
            questionTypes = command.questionTypes,
            language = command.language
        )

        val generationResult = try {
            questionGeneratorPort.generateQuestions(config)
        } catch (e: Exception) {
            log.error("‚ùå Generation failed: {}", e.message, e)
            // Rollback: supprimer le goal cr√©√©
            return GenerateExamResult.GenerationFailed(
                message = "√âchec de la g√©n√©ration: ${e.message}"
            )
        }

        // 4. Sauvegarder les questions
        val savedQuestions = generationResult.questions.map { generated ->
            val question = Question(
                id = QuestionId(0L), // Generated by DB
                goalId = savedGoal.id,
                type = generated.type,
                prompt = generated.prompt,
                answer = generated.answer,
                choices = generated.choices?.map { Choice(label = it.label, isCorrect = it.isCorrect) },
                explanation = generated.explanation,
                difficulty = generated.difficulty,
                chapter = generated.chapter,
                tags = generated.tags,
                createdAt = now
            )
            questionPort.save(question)
        }

        log.info("‚úÖ Generated {} questions for exam: {}", savedQuestions.size, savedGoal.id.value)

        return GenerateExamResult.Success(
            goal = savedGoal,
            questions = savedQuestions,
            topicAnalysis = generationResult.topicAnalysis,
            metadata = generationResult.generationMetadata
        )
    }
}

sealed class GenerateExamResult {
    data class Success(
        val goal: Goal,
        val questions: List<Question>,
        val topicAnalysis: TopicAnalysis,
        val metadata: GenerationMetadata
    ) : GenerateExamResult()

    data class NotPremium(
        val message: String
    ) : GenerateExamResult()

    data class GenerationFailed(
        val message: String
    ) : GenerateExamResult()
}
