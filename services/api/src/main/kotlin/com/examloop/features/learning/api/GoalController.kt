package com.examloop.features.learning.api

import com.examloop.features.learning.application.*
import com.examloop.features.learning.domain.*
import org.slf4j.LoggerFactory
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.time.Instant

/**
 * GoalController â€” API REST pour les Goals (Exams)
 */
@RestController
@RequestMapping("/api/v1/goals")
class GoalController(
    private val goalPort: GoalPort,
    private val questionPort: QuestionPort,
    private val reviewStatePort: ReviewStatePort,
    private val clockPort: ClockPort
) {
    private val log = LoggerFactory.getLogger(GoalController::class.java)

    @GetMapping
    fun listGoals(
        @RequestHeader("X-Device-Id") deviceId: String
    ): ResponseEntity<GoalsListResponse> {
        log.info("ðŸ“š GET /goals - deviceId: {}", deviceId)

        val userId = UserId(deviceId)
        val now = clockPort.now()

        // RÃ©cupÃ©rer les goals de l'utilisateur + goals publics
        val userGoals = goalPort.findByUserId(userId)
        val publicGoals = goalPort.findPublicGoals()
        val allGoals = (userGoals + publicGoals).distinctBy { it.id }

        // Calculer les stats pour chaque goal
        val dueStates = reviewStatePort.findDueForReview(userId, now)
        val dueByGoal = dueStates.groupBy { state ->
            questionPort.findById(state.questionId)?.goalId
        }

        val goalResponses = allGoals.map { goal ->
            val questions = questionPort.findByGoalId(goal.id)
            val dueCount = dueByGoal[goal.id]?.size ?: 0

            ResponseMapper.toGoalResponse(goal, questions.size, dueCount)
        }

        return ResponseEntity.ok(GoalsListResponse(goalResponses))
    }

    @GetMapping("/public")
    fun listPublicGoals(): ResponseEntity<GoalsListResponse> {
        log.info("ðŸŒ GET /goals/public")

        val publicGoals = goalPort.findPublicGoals()

        val goalResponses = publicGoals.map { goal ->
            val questions = questionPort.findByGoalId(goal.id)
            ResponseMapper.toGoalResponse(goal, questions.size, 0)
        }

        return ResponseEntity.ok(GoalsListResponse(goalResponses))
    }

    @PostMapping
    fun createGoal(
        @RequestHeader("X-Device-Id") deviceId: String,
        @RequestBody request: CreateGoalRequest
    ): ResponseEntity<*> {
        log.info("âž• POST /goals - deviceId: {}, title: {}", deviceId, request.title)

        // Validation
        if (request.title.isBlank()) {
            return ResponseEntity.badRequest().body(
                ProblemDetail(
                    title = "Validation error",
                    status = 400,
                    detail = "Title is required",
                    errorCode = "VALIDATION_FAILED"
                )
            )
        }

        if (request.title.length > 80) {
            return ResponseEntity.badRequest().body(
                ProblemDetail(
                    title = "Validation error",
                    status = 400,
                    detail = "Title must be 80 characters or less",
                    errorCode = "VALIDATION_FAILED"
                )
            )
        }

        val goal = Goal(
            id = GoalId(0L), // Will be generated by DB
            userId = UserId(deviceId),
            title = request.title.trim(),
            description = request.description?.trim(),
            isPublic = request.isPublic,
            createdAt = Instant.now()
        )

        val savedGoal = goalPort.save(goal)

        return ResponseEntity.status(HttpStatus.CREATED).body(
            ResponseMapper.toGoalResponse(savedGoal, 0, 0)
        )
    }

    @GetMapping("/{id}")
    fun getGoal(
        @RequestHeader("X-Device-Id") deviceId: String,
        @PathVariable id: Long
    ): ResponseEntity<*> {
        log.info("ðŸ“– GET /goals/{} - deviceId: {}", id, deviceId)

        val goalId = GoalId(id)

        val goal = goalPort.findById(goalId)
            ?: return ResponseEntity.status(HttpStatus.NOT_FOUND).body(
                ProblemDetail(
                    title = "Goal not found",
                    status = 404,
                    detail = "Goal with ID $id not found",
                    errorCode = "GOAL_NOT_FOUND"
                )
            )

        val userId = UserId(deviceId)
        val questions = questionPort.findByGoalId(goalId)
        val dueStates = reviewStatePort.findDueForReview(userId, clockPort.now())
            .filter { state -> questions.any { it.id == state.questionId } }

        return ResponseEntity.ok(
            ResponseMapper.toGoalResponse(goal, questions.size, dueStates.size)
        )
    }
}
